<!DOCTYPE html>
<html class="index">

<head>
    <link rel="stylesheet" type="text/css" href="./index.css">
</head>

<body>
    <header>
        <p class="name">Amanda</p>
        <p class="label">学习从来不嫌晚，加油，你肯定是最棒的那一个！trust yourself！</p>
        <image src="./assets/imgs/avatar.jpg" class="avatar" />
    </header>
    <div class="content">
        <div class="content-left">
            <div>
                <h1>知识点</h1>
                <h2>开发规范：</h2>
                <a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow">正确的开发流程Git-flow</a>
                <div>
                    <h2>HTML DOM => Node NodeType Element NodeList</h2>
                    <a href="http://10tiao.com/html/400/201504/205221675/1.html">JavaScript中Element与Node的区别，children与childNodes的区别</a>
                    <div>
                        <h2>HTML DOM 节点</h2>
                        <p>在 HTML DOM （文档对象模型）中，每个部分都是节点：</p>
                        <ul>
                            <li>文档本身是文档节点</li>
                            <li>所有 HTML 元素是元素节点</li>
                            <li>所有 HTML 属性是属性节点</li>
                            <li>HTML 元素内的文本是文本节点</li>
                            <li>注释是注释节点</li>
                        </ul>
                    </div>
                    <div>
                        <h2>Node?</h2>
                        <p>Node(节点)是DOM层次结构中的任何类型的对象的通用名称，Node有很多类型，如元素节点，属性节点，文本节点，注释节点等，</p>
                        <p>Node有几个子类型：Element,Text, Attribute,RootElement,Comment,Namespace等,这里就是通过NodeType区分</p>
                        <table class="dataintable" style="margin: 0px auto; border: 1px solid #c0c0c0; border-collapse: collapse; color: #333333; font-family: Georgia, 'Times New Roman', Times, san-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 25px; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; background-color: #ffffff; width: 440px; height: 153px;"
                            cellspacing="0" cellpadding="0">
                            <tbody>
                                <tr>
                                    <th style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px;">节点类型</th>
                                    <th style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px;">NodeType</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">元素element</td>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">1</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">属性attr</td>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">2</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">文本text</td>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">3</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">注释comments</td>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">8</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">文档document</td>
                                    <td style="border: 1px solid #c0c0c0; border-collapse: collapse; padding: 3px; word-break: normal !important;">9</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Node具有childNodes属性，获取到的列表就是NodeList类型</p>
                        <h2>Element?</h2>
                        <p><strong>Element</strong>继承了Node类，也就是说<strong>Element</strong>是Node多种类型中的一种，即当NodeType为1时Node即为ElementNode，另外<strong>Element</strong>扩展了Node，<strong>Element</strong>拥有id、class、children等属性，当然也有childNodes属性，但是获取到的值不一样，children获取到的就是元素，childNodes获得的就是包含空白的Text的节点</p>
                        <p>元素(Element)和结点(Node)的区别，元素是一个小范围的定义，必须是含有完整信息的结点才是一个元素，例如&lt;div&gt;…&lt;/div&gt;。但是一个结点不一定是一个元素，而一个元素一定是一个结点。</p>
                        <p style="color: red;">一个需要注意的地方就是，HTML文档两个标签之间的空白也是这棵树的一个节点（Text节点）。 &lt;a&gt; &lt;b&gt;&lt;/b&gt; &lt;a&gt; 中a有三个节点text, b , text</p>
                        <img src="./assets/imgs/elements_fun1.jpg" alt="">
                        <img src="./assets/imgs/elements_fun2.jpg" alt="">
                        <img src="./assets/imgs/elements_fun3.jpg" alt="">
                    </div>
                </div>
            </div>
            <div>
                <h1>前端面试难点集合</h1>
                <!-- ？页面布局方式 -->
                <div class="display-ques">
                    <h2>？页面布局方式</h2>
                    <h2>盒子模型</h2>
                    <h3>盒模型分为W3C标准盒模型和IE盒模型</h3>
                    <a href="https://juejin.im/post/59ef72f5f265da4320026f76">盒模型讲解</a>
                    <img class="display" src="./assets/imgs/display.png" alt="">
                    <div>
                        <h3>圣杯布局</h3>
                        <div class="wrap">
                            <div class="center">中间自适应</div>
                            <div class="left">左边栏</div>
                            <div class="right">右边栏</div>
                        </div>

                        <h3>双飞翼布局</h3>
                        <div class="wrap-two">
                            <div class="center-two">
                                <div class="center-two-inner">中间自适应</div>
                            </div>
                            <div class="left-two">左边栏</div>
                            <div class="right-two">右边栏</div>
                        </div>

                        <h2>浮动布局</h2>
                        <div class="wrap-three">
                            <div class="left-three">左边栏</div>
                            <div class="right-three">右边栏</div>
                            <div class="center-three">中间自适应</div>
                        </div>
                    </div>

                    <div class="grid-container">
                        <h3>flex grid 布局</h3>
                        <div class="header ">header</div>
                        <div class="content ">content</div>
                        <div class="sidebar ">sidebar</div>
                        <div class="footer ">footer</div>
                    </div>
                </div>
                <!-- ？浏览器加载页面的原理，怎样渲染dom -->
                <div class="browser-ques">
                    <h2>？浏览器加载页面的原理，怎样渲染dom</h2>
                    <p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面<a href="http://link.zhihu.com/?target=https%3A//developers.google.com/speed/docs/insights/mobile" class=" wrap external" target="_blank" rel="nofollow noopener noreferrer">五件事情<i class="icon-external"></i></a>上：</p>
                    <ol>
                        <li>DNS 查询：域名分析，打开相应站点</li>
                        <li>TCP 连接：三次握手</li>
                        <li>HTTP 请求即响应：包含请求头，请求方法，请求地址等等</li>
                        <li>服务器响应：得到response</li>
                        <li>客户端渲染：开始渲染
                            <ol>
                                <li>处理 HTML 标记并构建 DOM 树。</li>
                                <li>处理 CSS 标记并构建 CSSOM 树。</li>
                                <li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
                                <li>根据渲染树来布局，以计算每个节点的几何信息。</li>
                                <li>将各个节点绘制到屏幕上。</li>
                            </ol>
                        </li>
                    </ol>
                    <p>HTML解析器解析的过程中如果发现脚本，就会发生阻塞渲染现象（不是停住不动，而是继续预加载），停止渲染直到JS执行完毕；解析过程中发现存在css资源时，也会发生阻塞，渲染暂停，直至CSSOM构建完毕；css的优先级比js高，就是等CSSOM构建完毕JS继续执行；当然JS有defer延迟,async异步</p>
                    <a href="https://juejin.im/entry/59e1d31f51882578c3411c77">可查看这个相关文档，查看更详细的渲染dom介绍</a>
                </div>
                <div class="http-request">
                    <h2>？HTTP请求过程</h2>
                    <p>HTTP协议就是基于TCP/IP协议模型来传输信息的。</p>
                    <p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。</p>
                    <img src="./assets/imgs/http.jpg" alt="">
                    <article>
                        TCP/IP网络传输协议包含四层协议系统：链路层，网络层，传输层，应用层。<br> 链路层：通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。<br> 网络层：处理分组在网络中的活动，包含IP、ICMP、IGMP协议。<br> 传输层：为两台主机上的应用程序提供端到端的通信。TCP采用了超时重传、发送和接收端到端的确认分组等机制。<br> 应用层：决定了向用户提供应用服务时通信的活动，http协议，HTTP客户机发起一个与服务器的TCP连接，
                        一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP(网络套接字是IP地址与端口的组合)
                    </article>
                    <img src="./assets/imgs/tcp_connect.jpg" alt="">
                    <h3>http请求报文</h3>
                    <p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成</p>
                    <ol>
                        <li>
                            <p><strong>请求行（request line）</strong> </p>
                            <ol>
                                <li>请求方法</li>
                                <ul>
                                    <li><strong>GET</strong></li>
                                    <li><strong>POST</strong></li>
                                    <li><strong>PUT</strong></li>
                                    <li><strong>DELETE</strong></li>
                                    <li>PATCH</li>
                                    <li>HEAD</li>
                                    <li>OPTIONS</li>
                                    <li>TRACE</li>
                                </ul>
                                <li>
                                    <p>请求地址</p>
                                    <p>URL:统一资源定位符</p>
                                    <p>组成：
                                        <协议>：//
                                            <主机>：
                                                <端口>/
                                                    <路径>
                                    </p>
                                </li>
                                <li>
                                    <p>协议版本</p>
                                    <p>HTTP/主版本号.次版本号，常用的有HTTP/1.0,HTTP/1.1和HTTP2.0</p>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <p><strong>请求头部（header）</strong></p>
                            <p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p>
                        </li>
                        <li>
                            <p><strong>空行</strong></p>
                            <p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p>
                        </li>
                        <li>
                            <p><strong>请求数据</strong></p>
                            <p>下面是post请求，get请求没有请求数据。</p>
                            <blockquote>POST 　/index.php　HTTP/1.1 　　 请求行<br>Host: localhost<br>User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<i>/</i>;q=0.8<br>Accept-Language:
                                zh-cn,zh;q=0.5
                                <br>Accept-Encoding: gzip, deflate<br>Connection: keep-alive<br>Referer:
                                <a href="https://link.zhihu.com/?target=http%3A//localhost/" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">http://</span><span class="visible">localhost/</span><span class="invisible"></span></a><br>Content-Length：25<br>Content-Type：application/x-www-form-urlencoded<br>　　空行<br>username=aa&amp;password=1234　　请求数据
                            </blockquote>
                        </li>
                    </ol>
                    <h3>http响应报文</h3>
                    <p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据四个部分组成。</p>
                    <ol>
                        <li>
                            <p><strong>状态行</strong></p>
                            <ul>
                                <li>协议版本：于请求报文一致</li>
                                <li>
                                    状态码：分为3位数字
                                    <ul>
                                        <li>1xx：指示信息--表示请求已接收，继续处理</li>
                                        <li>2xx：成功--表示请求已被成功接收、理解、接受</li>
                                        <li>3xx：重定向--要完成请求必须进行更进一步的操作</li>
                                        <li>4xx：客户端错误--请求有语法错误或请求无法实现</li>
                                        <li>5xx：服务器端错误--服务器未能实现合法的请求</li>
                                    </ul>
                                    <img src="./assets/imgs/http_code.jpg" alt="">
                                </li>
                                <li>状态码描述：对状态码的描述</li>
                            </ul>
                        </li>
                        <li>
                            <p><strong>响应头部</strong></p>
                            <p>与请求头部类似，为响应报文添加了一些附加信息</p>
                        </li>
                        <li>
                            <p><strong>空行</strong></p>
                        </li>
                        <li>
                            <p><strong>响应数据</strong></p>
                            <p>下面是一个响应报文的实例：</p>
                            <blockquote>HTTP/1.1 200 OK　　状态行<br>Date: Sun, 17 Mar 2017 08:12:54 GMT　　响应头部<br>Server: Apache/2.2.8 (Win32) PHP/5.2.5<br>X-Powered-By: PHP/5.2.5<br>Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/<br>Expires: Thu, 19 Nov 1981
                                08:52:00 GMT
                                <br>Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br>Pragma: no-cache<br>Content-Length: 4393<br>Keep-Alive: timeout=5, max=100<br>Connection: Keep-Alive<br>Content-Type: text/html; charset=utf-8<br>　　空行<br>&lt;html&gt;　　响应数据<br>&lt;head&gt;<br>&lt;title&gt;HTTP响应示例&lt;title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>Hello
                                HTTP!
                                <br>&lt;/body&gt;<br>&lt;/html&gt;</blockquote>
                        </li>
                    </ol>
                    <div>
                        <h3>TCP四次挥手，断开连接</h3>
                        <p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
                        <p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。<br/>TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；<br/>但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；<br/>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
                        <img src="./assets/imgs/tcp_disconnect.jpg" alt="">
                    </div>
                </div>
                <!-- ？跨域的原理 同源性 -->
                <div class="cross-domain">
                    <h2>？跨域的原理 同源性</h2>
                    <p>浏览器的同源策略：（IE特殊）
                        <br/>如果两个页面的协议，主机和端口（如果有指定）都相同，则两个页面具有相同的源
                        <br/>源的继承：在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。
                    </p>
                    <p>
                        可以实现跨域的方式：
                        <ul>
                            <li>script标签嵌入跨域脚本</li>
                            <li>link标签嵌入css样式跨域</li>
                            <li>img标签引入跨域的资源</li>
                            <li>video，audio嵌入多媒体资源</li>
                            <li>@font-face实现字体的跨域</li>
                            <li>frame，iframe载入的跨域资源</li>
                        </ul>
                    </p>
                    <p>
                        如何允许跨域：
                        <br/>使用CORS允许跨域资源访问：CORS是一种机制，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。
                        <br/>使用JsonP允许跨域资源访问：借助script标签，引入jsonp文件，通过callback的形式实现跨域，不过只支持get请求
                        <p>跨源脚本api访问使用window window.blur,window.close,window.focus,window.postMessage,window.location,window.opener,window.parent等
                        </p>
                        <p>跨源数据存储访问：Cookies
                            <br/>不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。设置 cookie 时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。读取 cookie 时，不会知晓它的出处。 即使您仅使用安全的https连接，您看到的任何cookie都可能使用不安全的连接进行设置。
                            <br/>使用cookie可做带身份凭证的接口请求Access-Control-Allow-Origin设为允许的域名，将cookie信息带入
                            <br/>只有cookie的domain和path与请求的URL匹配才会发送这个cookie
                        </p>
                    </p>
                    <p>
                        如何阻止跨域：使用CSRF阻止跨域访问。资源不要采用上述可嵌入的方式
                    </p>
                </div>
                <!-- ？浏览器的缓存，性能优化 -->
                <div class="browser-cache">
                    <h2>？浏览器的缓存，性能优化</h2>
                    cache，manifest缓存，manifest文件需要在web服务器上面配置好，用来保证这些资源在任何情况下都能获得。
                </div>
                <!-- ？最新的 Web 开发标准，标准化，可用性 -->
                <div class="latest-web-standard">
                    <h2>？最新的 Web 开发标准，标准化，可用性</h2>
                </div>
                <!-- ？浏览器的兼容性 -->
                <div class="browser-compatibility">
                    <h2>？浏览器的兼容性</h2>
                </div>
                <div class="h5-new-element">
                    <h2>H5主要新增元素</h2>
                    <ul>
                        <li>用于绘画的 canvas 元素</li>
                        <li>用于媒介回放的 video 和 audio 元素</li>
                        <li>对本地离线存储的更好的支持</li>
                        <li>新的特殊内容元素，比如 article、footer、header、nav、section</li>
                        <li>新的表单控件，比如 calendar、date、time、email、url、search</li>
                    </ul>
                </div>
                <div class="css3-new">
                    <h2>CSS3主要新特性</h2>
                    <ul>
                        <li>动画</li>
                        <li>背景渐变</li>
                        <li>2D、3D转换</li>
                        <li>图片效果</li>
                        <li>盒模型</li>
                        <li>多列</li>
                    </ul>
                </div>
                <div class="promise-async-await">
                    <h2>Promise</h2>
                    <p>
                        promise是异步编程的一种解决方案。替代原生的各种回调函数和事件。
                        <br /> promise有三种状态，pending（进行中），fulfilled（成功），rejected（失败）；
                        <br /> 状态从pending到fulfilled，或者pending到rejected都是resolved，状态不会再改变。也就是说执行了resolve()方法之后状态就不会改变了；
                        <br /> 其构造函数接受一个函数作为参数，这个函数的两个参数分别是resolve和reject两个函数，在各个函数里面处理异步操作结果。
                        <br />也可用promise的实例.then((resolvedValue) => {}, (rejectedError) => {})的方式获得异步操作结果，resolve()方法执行之后就是then()方法接收的第一个参数方法； reject方法就是then()方法里面的接收的第二个参数，最好的方式是用catch()去接收报错信息，catch不仅可以接收promise的报错，也能抓取之前代码里面的错误，比如then里面的报错。
                        <br />Promise.all() 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例.
                        <br />Promise.all接收的参数必须是一个数组，数组里面都是promise实例，并且必须所有的子promise都返回fulfilled，该promise才会是fulfilled，否则只要有一个reject就是rejected
                        <br />Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
                        <br />Promise.all接收的参数必须是一个数组，数组里面都是promise实例，但是和all不一样的是只要子promise中有一个实例改变了状态，该promise状态就会跟着改变了
                        <br />Promise.resolve() 有时候需要将现有对象转为Promise对象，状态为resolved,将传入的参数可以是promise也可以是含有then的对象，还可以不带任何参数等等。执行then方法
                        <br />Promise.reject() 返回一个新的Promise的对象，状态为rejected.参数和resolve一样，但是如果是thenable的话会直接将thenable返回，而不是执行then方法。
                    </p>
                    <h2>async await</h2>
                    <p>async 是Generator函数的语法糖，表示这里有异步操作，需要结合await，告知紧跟后面的表达式这里需要等待结果</p>
                    <p>async函数返回一个Promise对象，那就可以then()，按照上面promise的流程走</p>
                    <p>await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值 </p>
                </div>
                <!-- ？js原型链，判断变量是否是function -->
                <div class="js-prototype">
                    <h2>？js原型链，浅拷贝深拷贝，判断变量是否是function</h2>
                </div>
                <!-- ？数据可视化工具 -->
                <div class="data-visibility">
                    <h2>？数据可视化工具</h2>
                </div>
                <!-- webpack的项目构建 -->
                <div class="webpack-build">
                    <h2>？webpack的项目构建</h2>
                </div>
            </div>
        </div>
        <div class="content-right">

        </div>
    </div>
</body>
<footer>
    <p>邮箱：maoxiang@163.com</p>
</footer>
<script>
    console.log('js应该放在文档的底部去引入，减少HTML渲染时的阻塞情况')
</script>

</html>